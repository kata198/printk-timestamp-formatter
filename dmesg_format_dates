#!/usr/bin/env python
#
# Copyright (c) 2015-2016 Tim Savannah under LGPLv3. See LICENSE for more information.
# This application prints the kernel log (dmesg), converting the timestamps to local time or utc,
#  adjusting for drift between the time systems.
import sys

import subprocess
import printk_timestamp_converter

defaultEncoding = sys.getdefaultencoding()
if bytes == str:
    # Python 2
    def tostr(x):
        if isinstance(x, unicode):
            return x.encode(defaultEncoding)
        else:
            return str(x)
else:
    # Python 3
    def tostr(x):
        if isinstance(x, bytes) is False:
            return str(x)
        return x.decode(defaultEncoding)

# TODO: Cleanup this printUsage, add other options
def printUsage():
    sys.stderr.write('''dmesg_format_dates (Options) - Formats kernel log (dmesg/kmsg), replacing the uptimes with timestamps, accounting for drift.
    
    
    The kernel logs messages with a timestamp of seconds since boot, which is an independent timesource from standard uptime and clocks, and often drifts by several seconds.

    This program takes account for adjusting time with those drifts. It will add a drift marker if one hasn't been added since a certain threshold (or use the printk_mark_drift program to explicitly add one).

    Timestamps are calculated using the drifts marked. The more you mark, the more accurate your timestamps will be.

    You may either run this program without providing input (in which it will call "dmesg"), or pipe in a kmsg log file/source.

       Options:

           --drift=N               Assume a fixed drift of N, instead of using (or adding) the drift markers.

       Output Formats (pick one):
       
           -l or --local           Output time on LOCAL format (DEFAULT).
           -u or --utc             Output time in UTC format.
           -e or --epoch           Output time in Unix Epoch format (seconds since Jan 1 1970 00:00:00)


    If your kernel log does not contain timestamps, run: echo "Y" > /sys/module/printk/parameters/time

''')

MODE_LOCAL = 0
MODE_UTC = 1
MODE_EPOCH = 2

pickedAMode = False

def err_tooManyModes():
    sys.stderr.write('You provided multiple modes (UTC, LOCAL, or EPOCH) as output format. Please pick one.\n')
    sys.exit(1)


if __name__ == '__main__':
    mode = MODE_LOCAL

    args = sys.argv[1:]
    currentDrift = None
    drifts = {}

    for arg in args:
        if arg in ('-u', '--utc'):
            mode = MODE_UTC
            if pickedAMode is True:
                err_tooManyModes()
            pickedAMode = True
        elif arg in ('--local', '-l'):
            mode = MODE_LOCAL
            if pickedAMode is True:
                err_tooManyModes()
            pickedAMode = True
        elif arg in ('-e', '--epoch'):
            mode = MODE_EPOCH
        elif arg in ('--help', '0h', '-?'):
            printUsage()
            sys.exit(0)
        elif arg.startswith('--drift='):
            try:
                currentDrift = drifts['earliest'] = drifts['latest'] = int(arg[arg.index('=')+1:])
            except ValueError:
                sys.stderr.write('--drift takes an integer argument.\n')
                sys.exit(1)
        else:
            sys.stderr.write('Unknown argument: %s\n\n' %(arg,))
            printUsage()
            sys.exit(1)


    try:
        if not sys.stdin.isatty():
            contents = sys.stdin.read()
            if currentDrift is None:
                drifts = printk_timestamp_converter.printk_calculateDrifts(contents)
        else:
            pipe = subprocess.Popen('dmesg', shell=True, stdout=subprocess.PIPE)
            contents = tostr(pipe.stdout.read())
            pipe.wait()
            if currentDrift is None:
                drifts = printk_timestamp_converter.printk_calculateDrifts()
    except printk_timestamp_converter.NotRecentEnoughDriftDelta as e:
        sys.stderr.write(str(e) + '\n')
        sys.exit(1)

    currentDrift = drifts['earliest']

    currentUptime = printk_timestamp_converter.getSystemUptime()

    lineNo = 0
    contentsSplit = contents.split('\n')

    if mode == MODE_EPOCH:
        getTimePortion = lambda printkSeconds, currentDrift : str(printk_timestamp_converter.printk_convertTimestampToEpoch(printkSeconds, currentDrift, currentUptime))
    elif mode == MODE_LOCAL:
        getTimePortion = lambda printkSeconds, currentDrift : printk_timestamp_converter.printk_convertTimestampToDatetime(printkSeconds, currentDrift, currentUptime).ctime()
    else:
        getTimePortion = lambda printkSeconds, currentDrift : printk_timestamp_converter.printk_convertTimestampToUTCDatetime(printkSeconds, currentDrift, currentUptime).ctime()

    if not contentsSplit[-1]:
        contentsSplit = contentsSplit[:-1]
    for line in contentsSplit:
        if lineNo in drifts:
            currentDrift = drifts[lineNo]

        matchObj = printk_timestamp_converter.PRINTK_WITH_TIME_PATTERN.match(line)
        if matchObj:
            printkSeconds = matchObj.groupdict()['printk_seconds']
            timePortion = getTimePortion(printkSeconds, currentDrift)
            
            try:   
                sys.stdout.write("[%s]%s\n" %(timePortion, line[line.index(']')+1:]) )
            except:
                break
        else:
            try:
                sys.stdout.write(line + "\n")
            except:
                break
        lineNo += 1

    # vim: sw=4 ts=4 expandtab
